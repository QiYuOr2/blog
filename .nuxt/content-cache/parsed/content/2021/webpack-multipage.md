{"parsed":{"_path":"/2021/webpack-multipage","_dir":"2021","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"使用Webpack构建多页面程序","description":"使用 webpack 搭建单页面程序十分常见，但在实际开发中我们可能还会有开发多页面程序的需求，因此我研究了一下如何使用 webpack 搭建多页面程序。","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 webpack 搭建单页面程序十分常见，但在实际开发中我们可能还会有开发多页面程序的需求，因此我研究了一下如何使用 webpack 搭建多页面程序。"}]},{"type":"element","tag":"h2","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将每个页面所在的文件夹都看作是一个单独的单页面程序目录，配置多个"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"entry"}]},{"type":"text","value":"以及"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"html-webpack-plugin"}]},{"type":"text","value":"即可实现多页面打包。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面为本项目目录结构"}]},{"type":"element","tag":"code","props":{"code":".\n├─ src\n│  └─ pages\n│       ├─ about\n│       │    ├─ index.css\n│       │    ├─ index.html\n│       │    └─ index.js\n│       └─ index\n│            ├─ index.css\n│            ├─ index.html\n│            └─ index.js\n└─ webpack.config.js\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":".\n├─ src\n│  └─ pages\n│       ├─ about\n│       │    ├─ index.css\n│       │    ├─ index.html\n│       │    └─ index.js\n│       └─ index\n│            ├─ index.css\n│            ├─ index.html\n│            └─ index.js\n└─ webpack.config.js\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"单页面打包基础配置"},"children":[{"type":"text","value":"单页面打包基础配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们来看一下单页面程序的 webpack 基础配置"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      filename: 'index.html',\n    }),\n  ],\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n  },\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      filename: 'index.html',\n    }),\n  ],\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n  },\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要想将其改为多页面程序，就要将它的单入口和单 HTML 模板改为多入口和多 HTML 模板"}]},{"type":"element","tag":"h2","props":{"id":"多页面打包基础配置"},"children":[{"type":"text","value":"多页面打包基础配置"}]},{"type":"element","tag":"h3","props":{"id":"改造入口"},"children":[{"type":"text","value":"改造入口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"传统的多入口写法可以写成键值对的形式"}]},{"type":"element","tag":"code","props":{"code":"module.exports = {\n  entry: {\n    index: './src/pages/index/index.js',\n    about: './src/pages/about/index.js',\n  },\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"module.exports = {\n  entry: {\n    index: './src/pages/index/index.js',\n    about: './src/pages/about/index.js',\n  },\n  ...\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样写的话，每增加一个页面就需要手动添加一个入口，比较麻烦，因此我们可以定义一个根据目录生成入口的函数来简化我们的操作"}]},{"type":"element","tag":"code","props":{"code":"const glob = require('glob');\n\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\nmodule.exports = {\n  entry: getEntry(),\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const glob = require('glob');\n\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\nmodule.exports = {\n  entry: getEntry(),\n  ...\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"改造输出"},"children":[{"type":"text","value":"改造输出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在输出的配置项中，再将输出的文件名写死显示已经不合适了，因此我们要将名字改为与源文件相匹配的名字"}]},{"type":"element","tag":"code","props":{"code":"module.exports = {\n  ...\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"module.exports = {\n  ...\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  ...\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"配置多个-html-webpack-plugin"},"children":[{"type":"text","value":"配置多个 html-webpack-plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与入口相同，可以将不同的 html 模板直接写入插件配置中，这里我们需要为每个插件配置不同的"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"chunks"}]},{"type":"text","value":"，防止 js 注入到错误的 html 中"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/pages/index/index.html',\n      chunks: ['index'],\n      filename: 'index.html',\n    }),\n    new HtmlWebpackPlugin({\n      template: './src/pages/about/index.html',\n      chunks: ['about'],\n      filename: 'about.html',\n    }),\n  ],\n  ...\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/pages/index/index.html',\n      chunks: ['index'],\n      filename: 'index.html',\n    }),\n    new HtmlWebpackPlugin({\n      template: './src/pages/about/index.html',\n      chunks: ['about'],\n      filename: 'about.html',\n    }),\n  ],\n  ...\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样的做法与入口有着同样的毛病，因此我们再定义一个函数来生成这个配置"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\n\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nmodule.exports = {\n  ...\n  plugins: [...getHtmlTemplate()],\n  ...\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\n\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nmodule.exports = {\n  ...\n  plugins: [...getHtmlTemplate()],\n  ...\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一个简单的多页面项目就配置完成了，我们还可以在此基础上添加热更新、代码分割等功能，有兴趣的可以自己尝试一下"}]},{"type":"element","tag":"h2","props":{"id":"完整配置"},"children":[{"type":"text","value":"完整配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"项目地址："},{"type":"element","tag":"a","props":{"href":"https://github.com/qiyuor2/webpack-multipage","rel":["nofollow"]},"children":[{"type":"text","value":"qiyuor2/webpack-multipage"}]}]},{"type":"element","tag":"code","props":{"code":"// webpack.config.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\n// 多页入口\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\n// 多页模板\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nconst config = {\n  mode: 'production',\n  entry: getEntry(),\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin(), ...getHtmlTemplate()],\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n    hot: true,\n    open: true,\n  },\n};\n\nmodule.exports = config;\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// webpack.config.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\n// 多页入口\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\n// 多页模板\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nconst config = {\n  mode: 'production',\n  entry: getEntry(),\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin(), ...getHtmlTemplate()],\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n    hot: true,\n    open: true,\n  },\n};\n\nmodule.exports = config;\n"}]}]}]}]},"date":"2021/03/15 20:32:48","tags":["webpack","JavaScript"],"category":"技术","summary":"使用webpack搭建单页面程序十分常见，但在实际开发中我们可能还会有开发多页面程序的需求，因此我研究了一下如何使用webpack搭建多页面程序。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 webpack 搭建单页面程序十分常见，但在实际开发中我们可能还会有开发多页面程序的需求，因此我研究了一下如何使用 webpack 搭建多页面程序。"}]},{"type":"element","tag":"h2","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将每个页面所在的文件夹都看作是一个单独的单页面程序目录，配置多个"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"entry"}]},{"type":"text","value":"以及"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"html-webpack-plugin"}]},{"type":"text","value":"即可实现多页面打包。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面为本项目目录结构"}]},{"type":"element","tag":"code","props":{"code":".\n├─ src\n│  └─ pages\n│       ├─ about\n│       │    ├─ index.css\n│       │    ├─ index.html\n│       │    └─ index.js\n│       └─ index\n│            ├─ index.css\n│            ├─ index.html\n│            └─ index.js\n└─ webpack.config.js\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":".\n├─ src\n│  └─ pages\n│       ├─ about\n│       │    ├─ index.css\n│       │    ├─ index.html\n│       │    └─ index.js\n│       └─ index\n│            ├─ index.css\n│            ├─ index.html\n│            └─ index.js\n└─ webpack.config.js\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"单页面打包基础配置"},"children":[{"type":"text","value":"单页面打包基础配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们来看一下单页面程序的 webpack 基础配置"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      filename: 'index.html',\n    }),\n  ],\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n  },\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      filename: 'index.html',\n    }),\n  ],\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n  },\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要想将其改为多页面程序，就要将它的单入口和单 HTML 模板改为多入口和多 HTML 模板"}]},{"type":"element","tag":"h2","props":{"id":"多页面打包基础配置"},"children":[{"type":"text","value":"多页面打包基础配置"}]},{"type":"element","tag":"h3","props":{"id":"改造入口"},"children":[{"type":"text","value":"改造入口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"传统的多入口写法可以写成键值对的形式"}]},{"type":"element","tag":"code","props":{"code":"module.exports = {\n  entry: {\n    index: './src/pages/index/index.js',\n    about: './src/pages/about/index.js',\n  },\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"module.exports = {\n  entry: {\n    index: './src/pages/index/index.js',\n    about: './src/pages/about/index.js',\n  },\n  ...\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样写的话，每增加一个页面就需要手动添加一个入口，比较麻烦，因此我们可以定义一个根据目录生成入口的函数来简化我们的操作"}]},{"type":"element","tag":"code","props":{"code":"const glob = require('glob');\n\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\nmodule.exports = {\n  entry: getEntry(),\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const glob = require('glob');\n\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\nmodule.exports = {\n  entry: getEntry(),\n  ...\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"改造输出"},"children":[{"type":"text","value":"改造输出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在输出的配置项中，再将输出的文件名写死显示已经不合适了，因此我们要将名字改为与源文件相匹配的名字"}]},{"type":"element","tag":"code","props":{"code":"module.exports = {\n  ...\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  ...\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"module.exports = {\n  ...\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  ...\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"配置多个-html-webpack-plugin"},"children":[{"type":"text","value":"配置多个 html-webpack-plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与入口相同，可以将不同的 html 模板直接写入插件配置中，这里我们需要为每个插件配置不同的"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"chunks"}]},{"type":"text","value":"，防止 js 注入到错误的 html 中"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/pages/index/index.html',\n      chunks: ['index'],\n      filename: 'index.html',\n    }),\n    new HtmlWebpackPlugin({\n      template: './src/pages/about/index.html',\n      chunks: ['about'],\n      filename: 'about.html',\n    }),\n  ],\n  ...\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/pages/index/index.html',\n      chunks: ['index'],\n      filename: 'index.html',\n    }),\n    new HtmlWebpackPlugin({\n      template: './src/pages/about/index.html',\n      chunks: ['about'],\n      filename: 'about.html',\n    }),\n  ],\n  ...\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样的做法与入口有着同样的毛病，因此我们再定义一个函数来生成这个配置"}]},{"type":"element","tag":"code","props":{"code":"const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\n\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nmodule.exports = {\n  ...\n  plugins: [...getHtmlTemplate()],\n  ...\n};\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\n\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nmodule.exports = {\n  ...\n  plugins: [...getHtmlTemplate()],\n  ...\n};\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一个简单的多页面项目就配置完成了，我们还可以在此基础上添加热更新、代码分割等功能，有兴趣的可以自己尝试一下"}]},{"type":"element","tag":"h2","props":{"id":"完整配置"},"children":[{"type":"text","value":"完整配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"项目地址："},{"type":"element","tag":"a","props":{"href":"https://github.com/qiyuor2/webpack-multipage","rel":["nofollow"]},"children":[{"type":"text","value":"qiyuor2/webpack-multipage"}]}]},{"type":"element","tag":"code","props":{"code":"// webpack.config.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\n// 多页入口\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\n// 多页模板\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nconst config = {\n  mode: 'production',\n  entry: getEntry(),\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin(), ...getHtmlTemplate()],\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n    hot: true,\n    open: true,\n  },\n};\n\nmodule.exports = config;\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// webpack.config.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst glob = require('glob');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\n// 多页入口\nfunction getEntry() {\n  const entry = {};\n  glob.sync('./src/pages/**/index.js').forEach((file) => {\n    const name = file.match(/\\/pages\\/(.+)\\/index.js/)[1];\n    entry[name] = file;\n  });\n  return entry;\n}\n\n// 多页模板\nfunction getHtmlTemplate() {\n  return glob\n    .sync('./src/pages/**/index.html')\n    .map((file) => {\n      return { name: file.match(/\\/pages\\/(.+)\\/index.html/)[1], path: file };\n    })\n    .map(\n      (template) =>\n        new HtmlWebpackPlugin({\n          template: template.path,\n          chunks: [template.name.toString()],\n          filename: `${template.name}.html`,\n        })\n    );\n}\n\nconst config = {\n  mode: 'production',\n  entry: getEntry(),\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'js/[name].[contenthash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin(), ...getHtmlTemplate()],\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n    hot: true,\n    open: true,\n  },\n};\n\nmodule.exports = config;\n"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"原理","depth":2,"text":"原理"},{"id":"单页面打包基础配置","depth":2,"text":"单页面打包基础配置"},{"id":"多页面打包基础配置","depth":2,"text":"多页面打包基础配置","children":[{"id":"改造入口","depth":3,"text":"改造入口"},{"id":"改造输出","depth":3,"text":"改造输出"},{"id":"配置多个-html-webpack-plugin","depth":3,"text":"配置多个 html-webpack-plugin"}]},{"id":"完整配置","depth":2,"text":"完整配置"}]}},"_type":"markdown","_id":"content:2021:webpack-multipage.md","_source":"content","_file":"2021/webpack-multipage.md","_extension":"md"},"hash":"jkxICRoq9v"}