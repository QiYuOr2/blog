{"parsed":{"_path":"/2020/js-datastructure","_dir":"2020","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"JavaScript实现常见的数据结构","description":"使用 JavaScript 实现栈、队列、链表、集合等常见数据结构。可能会有点用？","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 JavaScript 实现栈、队列、链表、集合等常见数据结构。可能会有点用？"}]},{"type":"element","tag":"h2","props":{"id":"栈stack"},"children":[{"type":"text","value":"栈(Stack)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上 JavaScript 的 Array 本身就具有栈和队列的特性，所以我们可以借助 Array 来实现它们。"}]},{"type":"element","tag":"code","props":{"code":"class Stack {\n  constructor() {\n    this.items = [];\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 获取栈顶元素\n  get peek() {\n    return this.items[this.items.length - 1];\n  }\n  push(element) {\n    this.items.push(element);\n  }\n  pop() {\n    this.items.pop();\n  }\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Stack {\n  constructor() {\n    this.items = [];\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 获取栈顶元素\n  get peek() {\n    return this.items[this.items.length - 1];\n  }\n  push(element) {\n    this.items.push(element);\n  }\n  pop() {\n    this.items.pop();\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"队列queue"},"children":[{"type":"text","value":"队列(Queue)"}]},{"type":"element","tag":"code","props":{"code":"class Queue {\n  constructor() {\n    this.items = [];\n  }\n  get isEmpty() {\n    return this.items.length === 0;\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 入队\n  enqueue(element) {\n    this.items.push(element);\n  }\n  // 出队\n  dequeue() {\n    return this.items.shift();\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Queue {\n  constructor() {\n    this.items = [];\n  }\n  get isEmpty() {\n    return this.items.length === 0;\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 入队\n  enqueue(element) {\n    this.items.push(element);\n  }\n  // 出队\n  dequeue() {\n    return this.items.shift();\n  }\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"优先队列"},"children":[{"type":"text","value":"优先队列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"队列的升级版本，给每个元素一个优先级，入队时会先排序。这里"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"PriorityQueue"}]},{"type":"text","value":"继承自"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Queue"}]},{"type":"text","value":"，所以只需要重写"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enqueue"}]},{"type":"text","value":"方法。"}]},{"type":"element","tag":"code","props":{"code":"class PriorityQueue extends Queue {\n  /**\n   * 入队\n   * @param {*} element 元素\n   * @param {*} priority 优先级\n   */\n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    if (this.isEmpty) {\n      super.enqueue(queueElement);\n    } else {\n      const preIndex = this.items.findIndex(\n        (items) => queueElement.priority < items.priority\n      );\n      if (preIndex > -1) {\n        this.items.splice(preIndex, 0, queueElement);\n      } else {\n        super.enqueue(queueElement);\n      }\n    }\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class PriorityQueue extends Queue {\n  /**\n   * 入队\n   * @param {*} element 元素\n   * @param {*} priority 优先级\n   */\n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    if (this.isEmpty) {\n      super.enqueue(queueElement);\n    } else {\n      const preIndex = this.items.findIndex(\n        (items) => queueElement.priority < items.priority\n      );\n      if (preIndex > -1) {\n        this.items.splice(preIndex, 0, queueElement);\n      } else {\n        super.enqueue(queueElement);\n      }\n    }\n  }\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"循环队列"},"children":[{"type":"text","value":"循环队列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"循环队列可以想象为一个首尾相连的圆环，相较于普通队列，它更节省空间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然同样继承自"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Queue"}]},{"type":"text","value":"，但基本上所有方法都重写了。"}]},{"type":"element","tag":"code","props":{"code":"class LoopQueue extends Queue {\n  constructor(maxSize) {\n    super();\n    this.maxSize = maxSize;\n    this.head = -1; //头指针\n    this.tail = -1; //尾指针\n  }\n  get isFull() {\n    return (this.tail + 1) % this.maxSize === this.head;\n  }\n  get isEmpty() {\n    return this.tail === -1 && this.head === -1;\n  }\n  enqueue(element) {\n    if (this.isFull) {\n      return false;\n    }\n    if (this.isEmpty) {\n      this.head = 0;\n    }\n    this.tail = (this.tail + 1) % this.maxSize;\n    this.items[this.tail] = element;\n    return true;\n  }\n  dequeue() {\n    if (!this.isEmpty) {\n      if (this.tail === this.head) {\n        this.tail = -1;\n        this.head = -1;\n      } else {\n        this.head = (this.head + 1) % this.maxSize;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class LoopQueue extends Queue {\n  constructor(maxSize) {\n    super();\n    this.maxSize = maxSize;\n    this.head = -1; //头指针\n    this.tail = -1; //尾指针\n  }\n  get isFull() {\n    return (this.tail + 1) % this.maxSize === this.head;\n  }\n  get isEmpty() {\n    return this.tail === -1 && this.head === -1;\n  }\n  enqueue(element) {\n    if (this.isFull) {\n      return false;\n    }\n    if (this.isEmpty) {\n      this.head = 0;\n    }\n    this.tail = (this.tail + 1) % this.maxSize;\n    this.items[this.tail] = element;\n    return true;\n  }\n  dequeue() {\n    if (!this.isEmpty) {\n      if (this.tail === this.head) {\n        this.tail = -1;\n        this.head = -1;\n      } else {\n        this.head = (this.head + 1) % this.maxSize;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"链表linked-list"},"children":[{"type":"text","value":"链表(Linked List)"}]},{"type":"element","tag":"code","props":{"code":"// 节点\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n// 链表\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 追加\n  append(element) {\n    const node = new Node(element);\n    let current = null;\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = node;\n    }\n    this.length++;\n  }\n  /**\n   * 插入\n   * @param {*} element 元素\n   * @param {*} position 位置\n   */\n  insert(element, position) {\n    if (position >= 0 && position <= this.length) {\n      const node = new Node(element);\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = node;\n        this.head.next = current;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        node.next = current;\n        previous.next = node;\n      }\n      this.length++;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 删除\n   * @param {*} position 位置\n   */\n  removeAt(position) {\n    if (position >= 0 && position < this.length) {\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = current.next;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      this.length--;\n      return current.element;\n    }\n    return null;\n  }\n  // 查找元素所在位置\n  indexOf(element) {\n    let current = this.head;\n    let index = 0;\n    while (current) {\n      if (element === current.element) {\n        return index;\n      }\n      index++;\n      current = current.next;\n    }\n    return -1;\n  }\n  // 根据元素删除\n  remove(element) {\n    const index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  toString() {\n    let current = this.head;\n    let string = '';\n    while (current) {\n      string += `${current.element} -- `;\n      current = current.next;\n    }\n    string += '*';\n\n    return string;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 节点\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n// 链表\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 追加\n  append(element) {\n    const node = new Node(element);\n    let current = null;\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = node;\n    }\n    this.length++;\n  }\n  /**\n   * 插入\n   * @param {*} element 元素\n   * @param {*} position 位置\n   */\n  insert(element, position) {\n    if (position >= 0 && position <= this.length) {\n      const node = new Node(element);\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = node;\n        this.head.next = current;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        node.next = current;\n        previous.next = node;\n      }\n      this.length++;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 删除\n   * @param {*} position 位置\n   */\n  removeAt(position) {\n    if (position >= 0 && position < this.length) {\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = current.next;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      this.length--;\n      return current.element;\n    }\n    return null;\n  }\n  // 查找元素所在位置\n  indexOf(element) {\n    let current = this.head;\n    let index = 0;\n    while (current) {\n      if (element === current.element) {\n        return index;\n      }\n      index++;\n      current = current.next;\n    }\n    return -1;\n  }\n  // 根据元素删除\n  remove(element) {\n    const index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  toString() {\n    let current = this.head;\n    let string = '';\n    while (current) {\n      string += `${current.element} -- `;\n      current = current.next;\n    }\n    string += '*';\n\n    return string;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"集合set"},"children":[{"type":"text","value":"集合(Set)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ES6 中引入了集合类型，可以参考一下。"}]},{"type":"element","tag":"code","props":{"code":"class Set {\n  constructor() {\n    this.items = {};\n  }\n  get size() {\n    return Object.keys(this.items).length;\n  }\n  get values() {\n    return Object.keys(this.items);\n  }\n  // 判断元素是否存在\n  has(value) {\n    return this.items.hasOwnProperty(value);\n  }\n  add(value) {\n    if (!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n  remove(value) {\n    if (this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n  // 并集\n  union(otherSet) {\n    const unionSet = new MySet();\n    this.values.forEach((value) => unionSet.add(this.value));\n    otherSet.values.forEach((value) => unionSet.add(otherSet.value));\n    return unionSet;\n  }\n  // 交集\n  intersection(otherSet) {\n    const intersectionSet = new MySet();\n    this.values.forEach((value, index) => {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  // 差集\n  difference(otherSet) {\n    const differenceSet = new MySet();\n    this.values.forEach((value) => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  // 子集\n  subset(otherSet) {\n    return this.values.every((value) => otherSet.has(value));\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Set {\n  constructor() {\n    this.items = {};\n  }\n  get size() {\n    return Object.keys(this.items).length;\n  }\n  get values() {\n    return Object.keys(this.items);\n  }\n  // 判断元素是否存在\n  has(value) {\n    return this.items.hasOwnProperty(value);\n  }\n  add(value) {\n    if (!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n  remove(value) {\n    if (this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n  // 并集\n  union(otherSet) {\n    const unionSet = new MySet();\n    this.values.forEach((value) => unionSet.add(this.value));\n    otherSet.values.forEach((value) => unionSet.add(otherSet.value));\n    return unionSet;\n  }\n  // 交集\n  intersection(otherSet) {\n    const intersectionSet = new MySet();\n    this.values.forEach((value, index) => {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  // 差集\n  difference(otherSet) {\n    const differenceSet = new MySet();\n    this.values.forEach((value) => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  // 子集\n  subset(otherSet) {\n    return this.values.every((value) => otherSet.has(value));\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"字典dictionary"},"children":[{"type":"text","value":"字典(Dictionary)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 JavaScript 中，"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Object"}]},{"type":"text","value":"对象实际上就是字典，都是以"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"{ key: value }"}]},{"type":"text","value":"的形式存储数据的。"}]},{"type":"element","tag":"code","props":{"code":"class Dictionary {\n  constructor() {\n    this.items = {};\n  }\n  get keys() {\n    return Object.keys(this.items);\n  }\n  get values() {\n    const r = [];\n    Object.keys(this.items).forEach((value) => {\n      r.push(this.items[value]);\n    });\n    return r;\n  }\n  set(key, value) {\n    this.items[key] = value;\n  }\n  get(key) {\n    return this.items[key];\n  }\n  remove(key) {\n    delete this.items[key];\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Dictionary {\n  constructor() {\n    this.items = {};\n  }\n  get keys() {\n    return Object.keys(this.items);\n  }\n  get values() {\n    const r = [];\n    Object.keys(this.items).forEach((value) => {\n      r.push(this.items[value]);\n    });\n    return r;\n  }\n  set(key, value) {\n    this.items[key] = value;\n  }\n  get(key) {\n    return this.items[key];\n  }\n  remove(key) {\n    delete this.items[key];\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"哈希表hash-table"},"children":[{"type":"text","value":"哈希表(Hash Table)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"哈希表也是以键值对的形式存储数据的，但是因为每个数据都会根据"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"key"}]},{"type":"text","value":"生成唯一的哈希值，所以查询速度非常快。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里散列函数就是用来生成哈希值的，随便写的，常用的构造散列函数的方法在网上能查到很多。"}]},{"type":"element","tag":"code","props":{"code":"class HashTable {\n  constructor() {\n    this.table = [];\n  }\n  // 散列函数\n  getHashCode(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return (hash % 64) * 0xffffff;\n  }\n  put(key, value) {\n    const position = this.getHashCode(key);\n    this.table[position] = value;\n  }\n  get(key) {\n    return this.table[this.getHashCode(key)];\n  }\n  remove(key) {\n    this.table[this.getHashCode(key)] = undefined;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class HashTable {\n  constructor() {\n    this.table = [];\n  }\n  // 散列函数\n  getHashCode(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return (hash % 64) * 0xffffff;\n  }\n  put(key, value) {\n    const position = this.getHashCode(key);\n    this.table[position] = value;\n  }\n  get(key) {\n    return this.table[this.getHashCode(key)];\n  }\n  remove(key) {\n    this.table[this.getHashCode(key)] = undefined;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"树tree"},"children":[{"type":"text","value":"树(tree)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正常的二叉树没有必要实现，这里实现一下二叉搜索树。"}]},{"type":"element","tag":"code","props":{"code":"class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(data) {\n    const newNode = new Node(data);\n    const insertNode = (node, newNode) => {\n      if (newNode.data < node.data) {\n        if (node.left === null) {\n          node.left = newNode;\n        } else {\n          insertNode(node.left, newNode);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = newNode;\n        } else {\n          insertNode(node.right, newNode);\n        }\n      }\n    };\n    if (!this.root) {\n      this.root = newNode;\n    } else {\n      insertNode(this.root, newNode);\n    }\n  }\n  // 中序遍历\n  inOrderTraverse(callback) {\n    const inOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        inOrderTraverseNode(node.left, callback);\n        callback(node.data);\n        inOrderTraverseNode(node.right, callback);\n      }\n    };\n    inOrderTraverseNode(this.root, callback);\n  }\n  // 先序遍历\n  preOrderTraverse(callback) {\n    const preOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        callback(node.data);\n        preOrderTraverseNode(node.left, callback);\n        preOrderTraverseNode(node.right, callback);\n      }\n    };\n    preOrderTraverseNode(this.root, callback);\n  }\n  // 后序遍历\n  postOrderTraverse(callback) {\n    const postOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        postOrderTraverseNode(node.left, callback);\n        postOrderTraverseNode(node.right, callback);\n        callback(node.data);\n      }\n    };\n    postOrderTraverseNode(this.root, callback);\n  }\n  min() {\n    let current = this.root;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current.data;\n  }\n  max() {\n    let current = this.root;\n    while (current.right !== null) {\n      current = current.right;\n    }\n    return current.data;\n  }\n  search(data) {\n    let current = this.root;\n    while (current.data !== data) {\n      if (data < current.data) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n      if (current == null) {\n        return null;\n      }\n    }\n    return current;\n  }\n  remove(data) {\n    const removeNode = (node, data) => {\n      if (node === null) {\n        return false;\n      }\n      if (node.data === data) {\n        if (node.left === null && node.right === null) {\n          return null;\n        }\n        if (node.left === null) {\n          return node.right;\n        }\n        if (node.right === null) {\n          return node.left;\n        }\n\n        let tempNode = node.right;\n        while (tempNode.left !== null) {\n          tempNode = tempNode.left;\n        }\n        node.data = tempNode.data;\n        node.right = removeNode(node.right, tempNode.data);\n        return node;\n      }\n      if (node.data > data) {\n        node.left = removeNode(node.left, data);\n        return node;\n      }\n      if (node.data < data) {\n        node.right = removeNode(node.right, data);\n        return node;\n      }\n    };\n    this.root = removeNode(this.root, data);\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(data) {\n    const newNode = new Node(data);\n    const insertNode = (node, newNode) => {\n      if (newNode.data < node.data) {\n        if (node.left === null) {\n          node.left = newNode;\n        } else {\n          insertNode(node.left, newNode);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = newNode;\n        } else {\n          insertNode(node.right, newNode);\n        }\n      }\n    };\n    if (!this.root) {\n      this.root = newNode;\n    } else {\n      insertNode(this.root, newNode);\n    }\n  }\n  // 中序遍历\n  inOrderTraverse(callback) {\n    const inOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        inOrderTraverseNode(node.left, callback);\n        callback(node.data);\n        inOrderTraverseNode(node.right, callback);\n      }\n    };\n    inOrderTraverseNode(this.root, callback);\n  }\n  // 先序遍历\n  preOrderTraverse(callback) {\n    const preOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        callback(node.data);\n        preOrderTraverseNode(node.left, callback);\n        preOrderTraverseNode(node.right, callback);\n      }\n    };\n    preOrderTraverseNode(this.root, callback);\n  }\n  // 后序遍历\n  postOrderTraverse(callback) {\n    const postOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        postOrderTraverseNode(node.left, callback);\n        postOrderTraverseNode(node.right, callback);\n        callback(node.data);\n      }\n    };\n    postOrderTraverseNode(this.root, callback);\n  }\n  min() {\n    let current = this.root;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current.data;\n  }\n  max() {\n    let current = this.root;\n    while (current.right !== null) {\n      current = current.right;\n    }\n    return current.data;\n  }\n  search(data) {\n    let current = this.root;\n    while (current.data !== data) {\n      if (data < current.data) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n      if (current == null) {\n        return null;\n      }\n    }\n    return current;\n  }\n  remove(data) {\n    const removeNode = (node, data) => {\n      if (node === null) {\n        return false;\n      }\n      if (node.data === data) {\n        if (node.left === null && node.right === null) {\n          return null;\n        }\n        if (node.left === null) {\n          return node.right;\n        }\n        if (node.right === null) {\n          return node.left;\n        }\n\n        let tempNode = node.right;\n        while (tempNode.left !== null) {\n          tempNode = tempNode.left;\n        }\n        node.data = tempNode.data;\n        node.right = removeNode(node.right, tempNode.data);\n        return node;\n      }\n      if (node.data > data) {\n        node.left = removeNode(node.left, data);\n        return node;\n      }\n      if (node.data < data) {\n        node.right = removeNode(node.right, data);\n        return node;\n      }\n    };\n    this.root = removeNode(this.root, data);\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"图graph"},"children":[{"type":"text","value":"图(Graph)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里实现的无向图。"}]},{"type":"element","tag":"code","props":{"code":"class Graph {\n  constructor() {\n    this.vertices = []; // 存顶点\n    this.adjList = {}; // 存边\n  }\n  // 顶点\n  addVertex(v) {\n    this.vertices.push(v);\n    this.adjList[v] = [];\n  }\n  // 边\n  addEdge(v, w) {\n    this.adjList[v].push(w);\n    this.adjList[w].push(v);\n  }\n  // 转化成邻接表的形式的字符串\n  toString() {\n    let str = '\\n';\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      str += v + ' => ';\n      const e = this.adjList[v];\n      for (let j = 0; j < e.length; j++) {\n        str += ' ' + e[j] + ' ';\n      }\n      str += '\\n';\n    }\n    return str;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Graph {\n  constructor() {\n    this.vertices = []; // 存顶点\n    this.adjList = {}; // 存边\n  }\n  // 顶点\n  addVertex(v) {\n    this.vertices.push(v);\n    this.adjList[v] = [];\n  }\n  // 边\n  addEdge(v, w) {\n    this.adjList[v].push(w);\n    this.adjList[w].push(v);\n  }\n  // 转化成邻接表的形式的字符串\n  toString() {\n    let str = '\\n';\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      str += v + ' => ';\n      const e = this.adjList[v];\n      for (let j = 0; j < e.length; j++) {\n        str += ' ' + e[j] + ' ';\n      }\n      str += '\\n';\n    }\n    return str;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"参考文章"},"children":[{"type":"text","value":"参考文章"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://juejin.im/post/594dfe795188250d725a220a#heading-14","rel":["nofollow"]},"children":[{"type":"text","value":"在 JavaScript 中学习数据结构与算法"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://segmentfault.com/a/1190000020011987","rel":["nofollow"]},"children":[{"type":"text","value":"常见数据结构和 Javascript 实现总结"}]}]}]}]},"date":"2020/01/29 15:26:47","tags":["JavaScript","数据结构"],"category":"技术","summary":"使用JavaScript实现栈、队列、链表、集合等常见数据结构。可能会有点用？","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 JavaScript 实现栈、队列、链表、集合等常见数据结构。可能会有点用？"}]},{"type":"element","tag":"h2","props":{"id":"栈stack"},"children":[{"type":"text","value":"栈(Stack)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上 JavaScript 的 Array 本身就具有栈和队列的特性，所以我们可以借助 Array 来实现它们。"}]},{"type":"element","tag":"code","props":{"code":"class Stack {\n  constructor() {\n    this.items = [];\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 获取栈顶元素\n  get peek() {\n    return this.items[this.items.length - 1];\n  }\n  push(element) {\n    this.items.push(element);\n  }\n  pop() {\n    this.items.pop();\n  }\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Stack {\n  constructor() {\n    this.items = [];\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 获取栈顶元素\n  get peek() {\n    return this.items[this.items.length - 1];\n  }\n  push(element) {\n    this.items.push(element);\n  }\n  pop() {\n    this.items.pop();\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"队列queue"},"children":[{"type":"text","value":"队列(Queue)"}]},{"type":"element","tag":"code","props":{"code":"class Queue {\n  constructor() {\n    this.items = [];\n  }\n  get isEmpty() {\n    return this.items.length === 0;\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 入队\n  enqueue(element) {\n    this.items.push(element);\n  }\n  // 出队\n  dequeue() {\n    return this.items.shift();\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Queue {\n  constructor() {\n    this.items = [];\n  }\n  get isEmpty() {\n    return this.items.length === 0;\n  }\n  get length() {\n    return this.items.length;\n  }\n  // 入队\n  enqueue(element) {\n    this.items.push(element);\n  }\n  // 出队\n  dequeue() {\n    return this.items.shift();\n  }\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"优先队列"},"children":[{"type":"text","value":"优先队列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"队列的升级版本，给每个元素一个优先级，入队时会先排序。这里"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"PriorityQueue"}]},{"type":"text","value":"继承自"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Queue"}]},{"type":"text","value":"，所以只需要重写"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enqueue"}]},{"type":"text","value":"方法。"}]},{"type":"element","tag":"code","props":{"code":"class PriorityQueue extends Queue {\n  /**\n   * 入队\n   * @param {*} element 元素\n   * @param {*} priority 优先级\n   */\n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    if (this.isEmpty) {\n      super.enqueue(queueElement);\n    } else {\n      const preIndex = this.items.findIndex(\n        (items) => queueElement.priority < items.priority\n      );\n      if (preIndex > -1) {\n        this.items.splice(preIndex, 0, queueElement);\n      } else {\n        super.enqueue(queueElement);\n      }\n    }\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class PriorityQueue extends Queue {\n  /**\n   * 入队\n   * @param {*} element 元素\n   * @param {*} priority 优先级\n   */\n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    if (this.isEmpty) {\n      super.enqueue(queueElement);\n    } else {\n      const preIndex = this.items.findIndex(\n        (items) => queueElement.priority < items.priority\n      );\n      if (preIndex > -1) {\n        this.items.splice(preIndex, 0, queueElement);\n      } else {\n        super.enqueue(queueElement);\n      }\n    }\n  }\n}\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"循环队列"},"children":[{"type":"text","value":"循环队列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"循环队列可以想象为一个首尾相连的圆环，相较于普通队列，它更节省空间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然同样继承自"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Queue"}]},{"type":"text","value":"，但基本上所有方法都重写了。"}]},{"type":"element","tag":"code","props":{"code":"class LoopQueue extends Queue {\n  constructor(maxSize) {\n    super();\n    this.maxSize = maxSize;\n    this.head = -1; //头指针\n    this.tail = -1; //尾指针\n  }\n  get isFull() {\n    return (this.tail + 1) % this.maxSize === this.head;\n  }\n  get isEmpty() {\n    return this.tail === -1 && this.head === -1;\n  }\n  enqueue(element) {\n    if (this.isFull) {\n      return false;\n    }\n    if (this.isEmpty) {\n      this.head = 0;\n    }\n    this.tail = (this.tail + 1) % this.maxSize;\n    this.items[this.tail] = element;\n    return true;\n  }\n  dequeue() {\n    if (!this.isEmpty) {\n      if (this.tail === this.head) {\n        this.tail = -1;\n        this.head = -1;\n      } else {\n        this.head = (this.head + 1) % this.maxSize;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class LoopQueue extends Queue {\n  constructor(maxSize) {\n    super();\n    this.maxSize = maxSize;\n    this.head = -1; //头指针\n    this.tail = -1; //尾指针\n  }\n  get isFull() {\n    return (this.tail + 1) % this.maxSize === this.head;\n  }\n  get isEmpty() {\n    return this.tail === -1 && this.head === -1;\n  }\n  enqueue(element) {\n    if (this.isFull) {\n      return false;\n    }\n    if (this.isEmpty) {\n      this.head = 0;\n    }\n    this.tail = (this.tail + 1) % this.maxSize;\n    this.items[this.tail] = element;\n    return true;\n  }\n  dequeue() {\n    if (!this.isEmpty) {\n      if (this.tail === this.head) {\n        this.tail = -1;\n        this.head = -1;\n      } else {\n        this.head = (this.head + 1) % this.maxSize;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"链表linked-list"},"children":[{"type":"text","value":"链表(Linked List)"}]},{"type":"element","tag":"code","props":{"code":"// 节点\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n// 链表\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 追加\n  append(element) {\n    const node = new Node(element);\n    let current = null;\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = node;\n    }\n    this.length++;\n  }\n  /**\n   * 插入\n   * @param {*} element 元素\n   * @param {*} position 位置\n   */\n  insert(element, position) {\n    if (position >= 0 && position <= this.length) {\n      const node = new Node(element);\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = node;\n        this.head.next = current;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        node.next = current;\n        previous.next = node;\n      }\n      this.length++;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 删除\n   * @param {*} position 位置\n   */\n  removeAt(position) {\n    if (position >= 0 && position < this.length) {\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = current.next;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      this.length--;\n      return current.element;\n    }\n    return null;\n  }\n  // 查找元素所在位置\n  indexOf(element) {\n    let current = this.head;\n    let index = 0;\n    while (current) {\n      if (element === current.element) {\n        return index;\n      }\n      index++;\n      current = current.next;\n    }\n    return -1;\n  }\n  // 根据元素删除\n  remove(element) {\n    const index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  toString() {\n    let current = this.head;\n    let string = '';\n    while (current) {\n      string += `${current.element} -- `;\n      current = current.next;\n    }\n    string += '*';\n\n    return string;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 节点\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n// 链表\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 追加\n  append(element) {\n    const node = new Node(element);\n    let current = null;\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = node;\n    }\n    this.length++;\n  }\n  /**\n   * 插入\n   * @param {*} element 元素\n   * @param {*} position 位置\n   */\n  insert(element, position) {\n    if (position >= 0 && position <= this.length) {\n      const node = new Node(element);\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = node;\n        this.head.next = current;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        node.next = current;\n        previous.next = node;\n      }\n      this.length++;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 删除\n   * @param {*} position 位置\n   */\n  removeAt(position) {\n    if (position >= 0 && position < this.length) {\n      let current = this.head;\n      let previous = null;\n      if (position === 0) {\n        this.head = current.next;\n      } else {\n        for (let index = 0; index < position; index++) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      this.length--;\n      return current.element;\n    }\n    return null;\n  }\n  // 查找元素所在位置\n  indexOf(element) {\n    let current = this.head;\n    let index = 0;\n    while (current) {\n      if (element === current.element) {\n        return index;\n      }\n      index++;\n      current = current.next;\n    }\n    return -1;\n  }\n  // 根据元素删除\n  remove(element) {\n    const index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  toString() {\n    let current = this.head;\n    let string = '';\n    while (current) {\n      string += `${current.element} -- `;\n      current = current.next;\n    }\n    string += '*';\n\n    return string;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"集合set"},"children":[{"type":"text","value":"集合(Set)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ES6 中引入了集合类型，可以参考一下。"}]},{"type":"element","tag":"code","props":{"code":"class Set {\n  constructor() {\n    this.items = {};\n  }\n  get size() {\n    return Object.keys(this.items).length;\n  }\n  get values() {\n    return Object.keys(this.items);\n  }\n  // 判断元素是否存在\n  has(value) {\n    return this.items.hasOwnProperty(value);\n  }\n  add(value) {\n    if (!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n  remove(value) {\n    if (this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n  // 并集\n  union(otherSet) {\n    const unionSet = new MySet();\n    this.values.forEach((value) => unionSet.add(this.value));\n    otherSet.values.forEach((value) => unionSet.add(otherSet.value));\n    return unionSet;\n  }\n  // 交集\n  intersection(otherSet) {\n    const intersectionSet = new MySet();\n    this.values.forEach((value, index) => {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  // 差集\n  difference(otherSet) {\n    const differenceSet = new MySet();\n    this.values.forEach((value) => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  // 子集\n  subset(otherSet) {\n    return this.values.every((value) => otherSet.has(value));\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Set {\n  constructor() {\n    this.items = {};\n  }\n  get size() {\n    return Object.keys(this.items).length;\n  }\n  get values() {\n    return Object.keys(this.items);\n  }\n  // 判断元素是否存在\n  has(value) {\n    return this.items.hasOwnProperty(value);\n  }\n  add(value) {\n    if (!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n  remove(value) {\n    if (this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n  // 并集\n  union(otherSet) {\n    const unionSet = new MySet();\n    this.values.forEach((value) => unionSet.add(this.value));\n    otherSet.values.forEach((value) => unionSet.add(otherSet.value));\n    return unionSet;\n  }\n  // 交集\n  intersection(otherSet) {\n    const intersectionSet = new MySet();\n    this.values.forEach((value, index) => {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  // 差集\n  difference(otherSet) {\n    const differenceSet = new MySet();\n    this.values.forEach((value) => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  // 子集\n  subset(otherSet) {\n    return this.values.every((value) => otherSet.has(value));\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"字典dictionary"},"children":[{"type":"text","value":"字典(Dictionary)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 JavaScript 中，"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"Object"}]},{"type":"text","value":"对象实际上就是字典，都是以"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"{ key: value }"}]},{"type":"text","value":"的形式存储数据的。"}]},{"type":"element","tag":"code","props":{"code":"class Dictionary {\n  constructor() {\n    this.items = {};\n  }\n  get keys() {\n    return Object.keys(this.items);\n  }\n  get values() {\n    const r = [];\n    Object.keys(this.items).forEach((value) => {\n      r.push(this.items[value]);\n    });\n    return r;\n  }\n  set(key, value) {\n    this.items[key] = value;\n  }\n  get(key) {\n    return this.items[key];\n  }\n  remove(key) {\n    delete this.items[key];\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Dictionary {\n  constructor() {\n    this.items = {};\n  }\n  get keys() {\n    return Object.keys(this.items);\n  }\n  get values() {\n    const r = [];\n    Object.keys(this.items).forEach((value) => {\n      r.push(this.items[value]);\n    });\n    return r;\n  }\n  set(key, value) {\n    this.items[key] = value;\n  }\n  get(key) {\n    return this.items[key];\n  }\n  remove(key) {\n    delete this.items[key];\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"哈希表hash-table"},"children":[{"type":"text","value":"哈希表(Hash Table)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"哈希表也是以键值对的形式存储数据的，但是因为每个数据都会根据"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"key"}]},{"type":"text","value":"生成唯一的哈希值，所以查询速度非常快。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里散列函数就是用来生成哈希值的，随便写的，常用的构造散列函数的方法在网上能查到很多。"}]},{"type":"element","tag":"code","props":{"code":"class HashTable {\n  constructor() {\n    this.table = [];\n  }\n  // 散列函数\n  getHashCode(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return (hash % 64) * 0xffffff;\n  }\n  put(key, value) {\n    const position = this.getHashCode(key);\n    this.table[position] = value;\n  }\n  get(key) {\n    return this.table[this.getHashCode(key)];\n  }\n  remove(key) {\n    this.table[this.getHashCode(key)] = undefined;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class HashTable {\n  constructor() {\n    this.table = [];\n  }\n  // 散列函数\n  getHashCode(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return (hash % 64) * 0xffffff;\n  }\n  put(key, value) {\n    const position = this.getHashCode(key);\n    this.table[position] = value;\n  }\n  get(key) {\n    return this.table[this.getHashCode(key)];\n  }\n  remove(key) {\n    this.table[this.getHashCode(key)] = undefined;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"树tree"},"children":[{"type":"text","value":"树(tree)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正常的二叉树没有必要实现，这里实现一下二叉搜索树。"}]},{"type":"element","tag":"code","props":{"code":"class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(data) {\n    const newNode = new Node(data);\n    const insertNode = (node, newNode) => {\n      if (newNode.data < node.data) {\n        if (node.left === null) {\n          node.left = newNode;\n        } else {\n          insertNode(node.left, newNode);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = newNode;\n        } else {\n          insertNode(node.right, newNode);\n        }\n      }\n    };\n    if (!this.root) {\n      this.root = newNode;\n    } else {\n      insertNode(this.root, newNode);\n    }\n  }\n  // 中序遍历\n  inOrderTraverse(callback) {\n    const inOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        inOrderTraverseNode(node.left, callback);\n        callback(node.data);\n        inOrderTraverseNode(node.right, callback);\n      }\n    };\n    inOrderTraverseNode(this.root, callback);\n  }\n  // 先序遍历\n  preOrderTraverse(callback) {\n    const preOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        callback(node.data);\n        preOrderTraverseNode(node.left, callback);\n        preOrderTraverseNode(node.right, callback);\n      }\n    };\n    preOrderTraverseNode(this.root, callback);\n  }\n  // 后序遍历\n  postOrderTraverse(callback) {\n    const postOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        postOrderTraverseNode(node.left, callback);\n        postOrderTraverseNode(node.right, callback);\n        callback(node.data);\n      }\n    };\n    postOrderTraverseNode(this.root, callback);\n  }\n  min() {\n    let current = this.root;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current.data;\n  }\n  max() {\n    let current = this.root;\n    while (current.right !== null) {\n      current = current.right;\n    }\n    return current.data;\n  }\n  search(data) {\n    let current = this.root;\n    while (current.data !== data) {\n      if (data < current.data) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n      if (current == null) {\n        return null;\n      }\n    }\n    return current;\n  }\n  remove(data) {\n    const removeNode = (node, data) => {\n      if (node === null) {\n        return false;\n      }\n      if (node.data === data) {\n        if (node.left === null && node.right === null) {\n          return null;\n        }\n        if (node.left === null) {\n          return node.right;\n        }\n        if (node.right === null) {\n          return node.left;\n        }\n\n        let tempNode = node.right;\n        while (tempNode.left !== null) {\n          tempNode = tempNode.left;\n        }\n        node.data = tempNode.data;\n        node.right = removeNode(node.right, tempNode.data);\n        return node;\n      }\n      if (node.data > data) {\n        node.left = removeNode(node.left, data);\n        return node;\n      }\n      if (node.data < data) {\n        node.right = removeNode(node.right, data);\n        return node;\n      }\n    };\n    this.root = removeNode(this.root, data);\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(data) {\n    const newNode = new Node(data);\n    const insertNode = (node, newNode) => {\n      if (newNode.data < node.data) {\n        if (node.left === null) {\n          node.left = newNode;\n        } else {\n          insertNode(node.left, newNode);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = newNode;\n        } else {\n          insertNode(node.right, newNode);\n        }\n      }\n    };\n    if (!this.root) {\n      this.root = newNode;\n    } else {\n      insertNode(this.root, newNode);\n    }\n  }\n  // 中序遍历\n  inOrderTraverse(callback) {\n    const inOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        inOrderTraverseNode(node.left, callback);\n        callback(node.data);\n        inOrderTraverseNode(node.right, callback);\n      }\n    };\n    inOrderTraverseNode(this.root, callback);\n  }\n  // 先序遍历\n  preOrderTraverse(callback) {\n    const preOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        callback(node.data);\n        preOrderTraverseNode(node.left, callback);\n        preOrderTraverseNode(node.right, callback);\n      }\n    };\n    preOrderTraverseNode(this.root, callback);\n  }\n  // 后序遍历\n  postOrderTraverse(callback) {\n    const postOrderTraverseNode = (node, callback) => {\n      if (node !== null) {\n        postOrderTraverseNode(node.left, callback);\n        postOrderTraverseNode(node.right, callback);\n        callback(node.data);\n      }\n    };\n    postOrderTraverseNode(this.root, callback);\n  }\n  min() {\n    let current = this.root;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current.data;\n  }\n  max() {\n    let current = this.root;\n    while (current.right !== null) {\n      current = current.right;\n    }\n    return current.data;\n  }\n  search(data) {\n    let current = this.root;\n    while (current.data !== data) {\n      if (data < current.data) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n      if (current == null) {\n        return null;\n      }\n    }\n    return current;\n  }\n  remove(data) {\n    const removeNode = (node, data) => {\n      if (node === null) {\n        return false;\n      }\n      if (node.data === data) {\n        if (node.left === null && node.right === null) {\n          return null;\n        }\n        if (node.left === null) {\n          return node.right;\n        }\n        if (node.right === null) {\n          return node.left;\n        }\n\n        let tempNode = node.right;\n        while (tempNode.left !== null) {\n          tempNode = tempNode.left;\n        }\n        node.data = tempNode.data;\n        node.right = removeNode(node.right, tempNode.data);\n        return node;\n      }\n      if (node.data > data) {\n        node.left = removeNode(node.left, data);\n        return node;\n      }\n      if (node.data < data) {\n        node.right = removeNode(node.right, data);\n        return node;\n      }\n    };\n    this.root = removeNode(this.root, data);\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"图graph"},"children":[{"type":"text","value":"图(Graph)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里实现的无向图。"}]},{"type":"element","tag":"code","props":{"code":"class Graph {\n  constructor() {\n    this.vertices = []; // 存顶点\n    this.adjList = {}; // 存边\n  }\n  // 顶点\n  addVertex(v) {\n    this.vertices.push(v);\n    this.adjList[v] = [];\n  }\n  // 边\n  addEdge(v, w) {\n    this.adjList[v].push(w);\n    this.adjList[w].push(v);\n  }\n  // 转化成邻接表的形式的字符串\n  toString() {\n    let str = '\\n';\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      str += v + ' => ';\n      const e = this.adjList[v];\n      for (let j = 0; j < e.length; j++) {\n        str += ' ' + e[j] + ' ';\n      }\n      str += '\\n';\n    }\n    return str;\n  }\n}\n","language":"javascript"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Graph {\n  constructor() {\n    this.vertices = []; // 存顶点\n    this.adjList = {}; // 存边\n  }\n  // 顶点\n  addVertex(v) {\n    this.vertices.push(v);\n    this.adjList[v] = [];\n  }\n  // 边\n  addEdge(v, w) {\n    this.adjList[v].push(w);\n    this.adjList[w].push(v);\n  }\n  // 转化成邻接表的形式的字符串\n  toString() {\n    let str = '\\n';\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v = this.vertices[i];\n      str += v + ' => ';\n      const e = this.adjList[v];\n      for (let j = 0; j < e.length; j++) {\n        str += ' ' + e[j] + ' ';\n      }\n      str += '\\n';\n    }\n    return str;\n  }\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"参考文章"},"children":[{"type":"text","value":"参考文章"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://juejin.im/post/594dfe795188250d725a220a#heading-14","rel":["nofollow"]},"children":[{"type":"text","value":"在 JavaScript 中学习数据结构与算法"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://segmentfault.com/a/1190000020011987","rel":["nofollow"]},"children":[{"type":"text","value":"常见数据结构和 Javascript 实现总结"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"栈stack","depth":2,"text":"栈(Stack)"},{"id":"队列queue","depth":2,"text":"队列(Queue)","children":[{"id":"优先队列","depth":3,"text":"优先队列"},{"id":"循环队列","depth":3,"text":"循环队列"}]},{"id":"链表linked-list","depth":2,"text":"链表(Linked List)"},{"id":"集合set","depth":2,"text":"集合(Set)"},{"id":"字典dictionary","depth":2,"text":"字典(Dictionary)"},{"id":"哈希表hash-table","depth":2,"text":"哈希表(Hash Table)"},{"id":"树tree","depth":2,"text":"树(tree)"},{"id":"图graph","depth":2,"text":"图(Graph)"},{"id":"参考文章","depth":2,"text":"参考文章"}]}},"_type":"markdown","_id":"content:2020:js-datastructure.md","_source":"content","_file":"2020/js-datastructure.md","_extension":"md"},"hash":"kHUpjxVUnh"}