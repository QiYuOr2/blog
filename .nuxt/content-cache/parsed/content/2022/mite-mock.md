{"parsed":{"_path":"/2022/mite-mock","_dir":"2022","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"无侵入式的接口Mock方案尝试","description":"通过中间人拦截并模拟接口，可以实现对项目无侵入的 mock 数据","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过中间人拦截并模拟接口，可以实现对项目无侵入的 mock 数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"demo: "},{"type":"element","tag":"a","props":{"href":"https://github.com/QiYuOr2/mitm-mock","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/QiYuOr2/mitm-mock"}]}]},{"type":"element","tag":"h2","props":{"id":"现状"},"children":[{"type":"text","value":"现状"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前后端并行开发时，需要模拟数据，直接在项目中 mock 对项目的侵入比较严重"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"需要单独控制某个接口或某些接口使用 mock 数据，因此直接使用后端的 mock 接口不合适"}]}]},{"type":"element","tag":"h2","props":{"id":"核心思路"},"children":[{"type":"text","value":"核心思路"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"流程","src":"https://gcore.jsdelivr.net/gh/qiyuor2/blog-image/img/20220812mitm-mock1.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"伪造数字证书"},"children":[{"type":"text","value":"伪造数字证书"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置代理服务器后客户端在发送 https 请求之前会向代理服务器发送 connect 请求，代理服务器监听 connect 请求，根据 connect 请求中的域名伪造数字证书"}]},{"type":"element","tag":"h3","props":{"id":"请求目标服务器无需-mock-的请求"},"children":[{"type":"text","value":"请求目标服务器（无需 Mock 的请求）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用伪造的数字证书创建 Server，将请求连接到该 Server（通过 hostname:port），在该 Server 中转发请求到目标服务器，最后将请求到的数据发回客户端"}]},{"type":"element","tag":"h3","props":{"id":"拦截并-mock-数据"},"children":[{"type":"text","value":"拦截并 Mock 数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在转发请求那一步时，可以不对请求进行转发，直接将自己 Mock 的数据填入 response 中发回客户端"}]},{"type":"element","tag":"h2","props":{"id":"参考"},"children":[{"type":"text","value":"参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/wuchangming/https-mitm-proxy-handbook","rel":["nofollow"]},"children":[{"type":"text","value":"基于 Node.js 的 HTTPS MITM(中间人)代理的原理和实现"}]}]}]}]},"date":"2022/08/12 16:03:04","summary":"使用中间人代理进行Mock","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过中间人拦截并模拟接口，可以实现对项目无侵入的 mock 数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"demo: "},{"type":"element","tag":"a","props":{"href":"https://github.com/QiYuOr2/mitm-mock","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/QiYuOr2/mitm-mock"}]}]},{"type":"element","tag":"h2","props":{"id":"现状"},"children":[{"type":"text","value":"现状"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前后端并行开发时，需要模拟数据，直接在项目中 mock 对项目的侵入比较严重"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"需要单独控制某个接口或某些接口使用 mock 数据，因此直接使用后端的 mock 接口不合适"}]}]},{"type":"element","tag":"h2","props":{"id":"核心思路"},"children":[{"type":"text","value":"核心思路"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"流程","src":"https://gcore.jsdelivr.net/gh/qiyuor2/blog-image/img/20220812mitm-mock1.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"伪造数字证书"},"children":[{"type":"text","value":"伪造数字证书"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置代理服务器后客户端在发送 https 请求之前会向代理服务器发送 connect 请求，代理服务器监听 connect 请求，根据 connect 请求中的域名伪造数字证书"}]},{"type":"element","tag":"h3","props":{"id":"请求目标服务器无需-mock-的请求"},"children":[{"type":"text","value":"请求目标服务器（无需 Mock 的请求）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用伪造的数字证书创建 Server，将请求连接到该 Server（通过 hostname:port），在该 Server 中转发请求到目标服务器，最后将请求到的数据发回客户端"}]},{"type":"element","tag":"h3","props":{"id":"拦截并-mock-数据"},"children":[{"type":"text","value":"拦截并 Mock 数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在转发请求那一步时，可以不对请求进行转发，直接将自己 Mock 的数据填入 response 中发回客户端"}]},{"type":"element","tag":"h2","props":{"id":"参考"},"children":[{"type":"text","value":"参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/wuchangming/https-mitm-proxy-handbook","rel":["nofollow"]},"children":[{"type":"text","value":"基于 Node.js 的 HTTPS MITM(中间人)代理的原理和实现"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"现状","depth":2,"text":"现状"},{"id":"核心思路","depth":2,"text":"核心思路","children":[{"id":"伪造数字证书","depth":3,"text":"伪造数字证书"},{"id":"请求目标服务器无需-mock-的请求","depth":3,"text":"请求目标服务器（无需 Mock 的请求）"},{"id":"拦截并-mock-数据","depth":3,"text":"拦截并 Mock 数据"}]},{"id":"参考","depth":2,"text":"参考"}]}},"_type":"markdown","_id":"content:2022:mite-mock.md","_source":"content","_file":"2022/mite-mock.md","_extension":"md"},"hash":"cOkXDAXtMW"}